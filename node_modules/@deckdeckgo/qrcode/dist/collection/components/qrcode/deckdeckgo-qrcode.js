import { Component, Element, Method, Prop, h, Watch } from '@stencil/core';
import * as QRCodeGenerator from '../utils/qrcode-generator/qrcode';
var DeckdeckgoQRCodeType;
(function (DeckdeckgoQRCodeType) {
  DeckdeckgoQRCodeType["SVG"] = "svg";
  DeckdeckgoQRCodeType["IMG"] = "img";
})(DeckdeckgoQRCodeType || (DeckdeckgoQRCodeType = {}));
export class DeckdeckgoQRCode {
  constructor() {
    this.type = DeckdeckgoQRCodeType.SVG;
  }
  async componentDidLoad() {
    await this.generate();
  }
  async onContentChange() {
    await this.generate();
  }
  generate() {
    return new Promise(async (resolve) => {
      const qrCode = await this.createQRCode();
      await this.parseQRCode(qrCode);
      resolve();
    });
  }
  createQRCode() {
    return new Promise((resolve) => {
      if (!this.content || this.content.length <= 0) {
        resolve(null);
        return;
      }
      QRCodeGenerator.qrcode.stringToBytesFuncs['UTF-8'];
      const qrGenerator = QRCodeGenerator.qrcode(0, 'H');
      qrGenerator.addData(this.content, 'Byte');
      qrGenerator.make();
      const qrCode = this.isQRCodeTypeImg()
        ? qrGenerator.createImgTag(this.qrCellSize, this.qrMargin, this.qrAlt, this.qrFillColor, this.qrBackgroundColor)
        : qrGenerator.createSvgTag(this.qrCellSize, this.qrMargin);
      resolve(qrCode);
    });
  }
  parseQRCode(qrCode) {
    return new Promise(async (resolve) => {
      if (!qrCode) {
        resolve();
        return;
      }
      const container = this.el.shadowRoot.querySelector('div.deckgo-qrcode-container');
      if (container) {
        this.removePreviousQRCode(container);
        try {
          const template = document.createElement('template');
          template.innerHTML = qrCode;
          container.appendChild(template.content.firstChild);
        }
        catch (err) {
          // Then we don't generate a QR code
        }
      }
      resolve();
    });
  }
  removePreviousQRCode(container) {
    const svg = container.querySelector('svg');
    if (svg) {
      svg.parentNode.removeChild(svg);
    }
    const img = container.querySelector('img');
    if (img) {
      img.parentNode.removeChild(img);
    }
  }
  isQRCodeTypeImg() {
    return this.type === DeckdeckgoQRCodeType.IMG;
  }
  render() {
    return (h("div", { class: "deckgo-qrcode-container" },
      h("slot", { name: "logo" })));
  }
  static get is() { return "deckgo-qrcode"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["deckdeckgo-qrcode.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["deckdeckgo-qrcode.css"]
  }; }
  static get properties() { return {
    "content": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "content",
      "reflect": false
    },
    "type": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "type",
      "reflect": false,
      "defaultValue": "DeckdeckgoQRCodeType.SVG"
    },
    "qrCellSize": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "qr-cell-size",
      "reflect": false
    },
    "qrMargin": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "qr-margin",
      "reflect": false
    },
    "qrBackgroundColor": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "qr-background-color",
      "reflect": false
    },
    "qrFillColor": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "qr-fill-color",
      "reflect": false
    },
    "qrAlt": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "qr-alt",
      "reflect": false
    }
  }; }
  static get methods() { return {
    "generate": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get watchers() { return [{
      "propName": "content",
      "methodName": "onContentChange"
    }]; }
}
